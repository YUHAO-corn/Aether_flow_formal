# 自动存储功能开发指南

## 1. 功能概述

自动存储功能是AetherFlow的核心功能之一，它能够自动捕获用户与各种AI平台（如ChatGPT、Claude、Bard等）的对话内容，并将其保存到本地或后端数据库中。这个功能对于用户管理和复用提示词非常重要。

### 1.1 功能需求

根据PRD文档，自动存储功能需要满足以下需求：

- 用户每次与AI平台对话时自动存储对话信息，包括使用哪个AI平台、时间、链接、本轮提问与本轮回答
- 滚动存储机制：每个用户默认保留最近100条未收藏的对话，超限时自动删除最旧未收藏内容
- 在界面底部显示小型浮动通知，提示用户最近一次已经自动保存
- 点击通知可以查看最近存储记录

## 2. 技术挑战

实现自动存储功能面临的主要技术挑战包括：

1. **不同AI平台的DOM结构差异**：每个AI平台（ChatGPT、Claude、Bard等）的网页结构不同，需要针对每个平台编写特定的捕获逻辑。
2. **动态内容捕获**：AI平台的回答通常是动态生成的，需要正确捕获完整的对话内容。
3. **避免重复存储**：需要设计机制避免重复存储相同的对话内容。
4. **用户隐私和安全**：需要确保用户数据的安全存储和传输。
5. **平台更新适应性**：AI平台可能会更新其网页结构，需要设计具有适应性的捕获机制。

## 3. 实现方案

### 3.1 浏览器扩展架构

浏览器扩展通常包含以下几个部分：

1. **内容脚本（Content Scripts）**：注入到目标网页中，负责捕获对话内容。
2. **背景脚本（Background Scripts）**：在扩展的后台运行，负责处理和存储捕获的数据。
3. **弹出界面（Popup）**：用户交互界面，显示存储状态和历史记录。
4. **侧边栏（Sidebar）**：提供更丰富的功能界面。

### 3.2 对话捕获方法

#### 3.2.1 通用捕获方法

1. **MutationObserver**：使用MutationObserver监听DOM变化，当检测到对话内容更新时触发捕获逻辑。
2. **定时轮询**：定期检查页面内容，捕获新的对话内容。
3. **事件监听**：监听特定事件（如按钮点击、表单提交等），触发捕获逻辑。

#### 3.2.2 平台特定捕获方法

##### ChatGPT

```javascript
function captureChatGPTConversation() {
  // ChatGPT的对话容器
  const conversationContainer = document.querySelector('main div.flex.flex-col.items-center');
  if (!conversationContainer) {
    return null;
  }
  
  // 获取所有对话项
  const conversationItems = conversationContainer.querySelectorAll('div.group');
  if (!conversationItems || conversationItems.length === 0) {
    return null;
  }
  
  const conversations = [];
  
  // 遍历对话项，提取用户提问和AI回答
  for (let i = 0; i < conversationItems.length; i += 2) {
    const userItem = conversationItems[i];
    const aiItem = conversationItems[i + 1];
    
    if (!userItem) continue;
    
    // 提取用户提问
    const userPrompt = userItem.querySelector('div[data-message-author-role="user"]');
    if (!userPrompt) continue;
    
    // 提取AI回答
    let aiResponse = '';
    if (aiItem) {
      const aiResponseElem = aiItem.querySelector('div[data-message-author-role="assistant"]');
      if (aiResponseElem) {
        aiResponse = aiResponseElem.textContent.trim();
      }
    }
    
    const conversation = {
      platform: 'ChatGPT',
      prompt: userPrompt.textContent.trim(),
      response: aiResponse,
      timestamp: new Date().toISOString(),
      url: window.location.href
    };
    
    conversations.push(conversation);
  }
  
  return conversations;
}
```

##### Claude

```javascript
function captureClaudeConversation() {
  // Claude的对话容器
  const conversationContainer = document.querySelector('.claude-container .conversation-container');
  if (!conversationContainer) {
    return null;
  }
  
  // 获取所有对话项
  const userMessages = conversationContainer.querySelectorAll('.user-message');
  const assistantMessages = conversationContainer.querySelectorAll('.assistant-message');
  
  if (!userMessages || userMessages.length === 0) {
    return null;
  }
  
  const conversations = [];
  
  // 遍历用户消息，提取用户提问和AI回答
  for (let i = 0; i < userMessages.length; i++) {
    const userMessage = userMessages[i];
    const assistantMessage = assistantMessages[i];
    
    // 提取用户提问
    const userPrompt = userMessage.querySelector('.message-content');
    if (!userPrompt) continue;
    
    // 提取AI回答
    let aiResponse = '';
    if (assistantMessage) {
      const aiResponseElem = assistantMessage.querySelector('.message-content');
      if (aiResponseElem) {
        aiResponse = aiResponseElem.textContent.trim();
      }
    }
    
    const conversation = {
      platform: 'Claude',
      prompt: userPrompt.textContent.trim(),
      response: aiResponse,
      timestamp: new Date().toISOString(),
      url: window.location.href
    };
    
    conversations.push(conversation);
  }
  
  return conversations;
}
```

##### Bard

```javascript
function captureBardConversation() {
  // Bard的对话容器
  const conversationContainer = document.querySelector('.conversation-container');
  if (!conversationContainer) {
    return null;
  }
  
  // 获取所有对话项
  const messageGroups = conversationContainer.querySelectorAll('.message-group');
  
  if (!messageGroups || messageGroups.length === 0) {
    return null;
  }
  
  const conversations = [];
  
  // 遍历消息组，提取用户提问和AI回答
  for (let i = 0; i < messageGroups.length; i++) {
    const messageGroup = messageGroups[i];
    
    // 提取用户提问
    const userPrompt = messageGroup.querySelector('.user-query');
    if (!userPrompt) continue;
    
    // 提取AI回答
    let aiResponse = '';
    const aiResponseElem = messageGroup.querySelector('.model-response');
    if (aiResponseElem) {
      aiResponse = aiResponseElem.textContent.trim();
    }
    
    const conversation = {
      platform: 'Bard',
      prompt: userPrompt.textContent.trim(),
      response: aiResponse,
      timestamp: new Date().toISOString(),
      url: window.location.href
    };
    
    conversations.push(conversation);
  }
  
  return conversations;
}
```

### 3.3 DOM变化监听

使用MutationObserver监听DOM变化，当检测到对话内容更新时触发捕获逻辑：

```javascript
// 定义MutationObserver监听DOM变化
const observer = new MutationObserver((mutations) => {
  // 防抖处理，避免频繁触发
  clearTimeout(window.autoSaveDebounceTimer);
  window.autoSaveDebounceTimer = setTimeout(() => {
    console.log('[AutoSave] 检测到DOM变化，尝试捕获对话');
    const conversations = captureConversation();
    
    if (conversations && conversations.length > 0) {
      // 过滤出新的对话
      const newConversations = conversations.filter(conv => {
        // 检查是否已经保存过
        return !lastCapturedConversations.some(lastConv => 
          lastConv.prompt === conv.prompt && 
          lastConv.response === conv.response
        );
      });
      
      if (newConversations.length > 0) {
        console.log(`[AutoSave] 发现 ${newConversations.length} 条新对话，准备保存`);
        
        // 更新最后捕获的对话
        lastCapturedConversations = [...lastCapturedConversations, ...newConversations];
        // 保持最后捕获的对话数量在合理范围内
        if (lastCapturedConversations.length > 50) {
          lastCapturedConversations = lastCapturedConversations.slice(-50);
        }
        
        // 发送消息到后台脚本保存对话
        chrome.runtime.sendMessage({
          action: 'saveConversations',
          conversations: newConversations
        });
      }
    }
  }, 1000); // 1秒防抖
});

// 开始观察DOM变化
observer.observe(document.body, {
  childList: true,
  subtree: true,
  characterData: true
});
```

### 3.4 数据存储

#### 3.4.1 本地存储

使用Chrome扩展的存储API将对话内容保存到本地：

```javascript
function saveConversationsToLocal(conversations) {
  console.log('[Background] 保存对话内容到本地存储:', conversations.length);
  
  // 获取现有的对话历史
  chrome.storage.local.get('conversationHistory', data => {
    let history = data.conversationHistory || [];
    
    // 添加新的对话内容
    history = [...conversations, ...history];
    
    // 限制历史记录大小
    if (history.length > MAX_HISTORY_SIZE) {
      console.log(`[Background] 历史记录超过${MAX_HISTORY_SIZE}条，截断至${MAX_HISTORY_SIZE}条`);
      history = history.slice(0, MAX_HISTORY_SIZE);
    }
    
    // 保存到本地存储
    chrome.storage.local.set({ 'conversationHistory': history }, () => {
      console.log('[Background] 对话内容已保存到本地存储，总条数:', history.length);
      
      // 更新保存状态
      const timestamp = new Date().toISOString();
      chrome.storage.local.set({ 
        'lastSaved': timestamp,
        'saveStatus': 'saved'
      });
      
      // 通知UI更新
      chrome.runtime.sendMessage({
        action: 'updateSaveStatus',
        status: 'saved',
        timestamp: timestamp
      });
    });
  });
}
```

#### 3.4.2 后端API存储

将对话内容发送到后端API进行存储：

```javascript
async function saveConversationsToAPI(conversations) {
  console.log('[Background] 保存对话内容到后端API:', conversations.length);
  
  try {
    // 更新保存状态
    chrome.storage.local.set({ 'saveStatus': 'saving' });
    
    // 通知UI更新
    chrome.runtime.sendMessage({
      action: 'updateSaveStatus',
      status: 'saving'
    });
    
    // 获取认证令牌
    const token = await new Promise(resolve => {
      chrome.storage.local.get('token', data => {
        console.log('[Background] 获取认证令牌:', data.token ? '成功' : '失败');
        resolve(data.token);
      });
    });
    
    if (!token) {
      console.log('[Background] 未找到认证令牌，跳过API保存');
      return false;
    }
    
    // 将对话内容转换为API需要的格式
    const promptsToSave = conversations.map(conv => ({
      title: `${conv.platform} 对话 - ${new Date(conv.timestamp).toLocaleString()}`,
      content: conv.prompt,
      response: conv.response,
      platform: conv.platform,
      url: conv.url,
      timestamp: conv.timestamp,
      type: 'conversation'
    }));
    
    // 调用API保存对话内容
    const results = await Promise.all(
      promptsToSave.map(prompt => {
        return promptAPI.autoSavePrompt(prompt);
      })
    );
    
    // 更新保存状态
    const timestamp = new Date().toISOString();
    chrome.storage.local.set({ 
      'lastSaved': timestamp,
      'saveStatus': 'saved'
    });
    
    // 通知UI更新
    chrome.runtime.sendMessage({
      action: 'updateSaveStatus',
      status: 'saved',
      timestamp: timestamp
    });
    
    return true;
  } catch (error) {
    console.error('[Background] API保存失败:', error);
    
    // 更新保存状态
    chrome.storage.local.set({ 'saveStatus': 'error' });
    
    // 通知UI更新
    chrome.runtime.sendMessage({
      action: 'updateSaveStatus',
      status: 'error',
      error: error.message
    });
    
    return false;
  }
}
```

### 3.5 用户界面

#### 3.5.1 状态指示器

在页面底部显示小型浮动通知，提示用户最近一次已经自动保存：

```jsx
<motion.button
  className={`flex items-center space-x-2 px-3 py-2 rounded-lg ${
    saveStatus === 'saving' 
      ? 'bg-blue-900/70 text-blue-300' 
      : saveStatus === 'error'
        ? 'bg-red-900/70 text-red-300'
        : 'bg-gray-800/70 text-gray-300 hover:bg-gray-700/70'
  } shadow-lg`}
  whileHover={{ y: -2 }}
  onClick={toggleExpand}
  aria-label="查看保存历史"
  style={{ backdropFilter: 'blur(4px)' }}
>
  {saveStatus === 'saving' ? (
    <motion.div 
      className="w-4 h-4 border-2 border-t-transparent border-blue-300 rounded-full"
      animate={{ rotate: 360 }}
      transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
    />
  ) : (
    saveStatus === 'error' ? (
      <motion.div 
        className="w-4 h-4 text-red-300"
        animate={{ scale: [1, 1.2, 1] }}
        transition={{ duration: 1, repeat: Infinity }}
      >
        !
      </motion.div>
    ) : (
      <RiSaveLine />
    )
  )}
  
  <div className="flex items-center space-x-1">
    <span>{saveStatus === 'saving' ? '保存中...' : saveStatus === 'error' ? '保存失败' : `已保存 ${formattedLastSaved}`}</span>
    <RiHistoryLine 
      className={`text-gray-400 ${isExpanded ? 'rotate-180' : ''} transition-transform`} 
      size={14} 
    />
  </div>
</motion.button>
```

#### 3.5.2 历史记录面板

点击状态指示器时显示历史记录面板：

```jsx
{isExpanded && (
  <motion.div
    className="absolute bottom-12 right-0 w-64 bg-gray-800 border border-gray-700 rounded-lg shadow-lg overflow-hidden"
    initial={{ opacity: 0, y: 10, height: 0 }}
    animate={{ opacity: 1, y: 0, height: 'auto' }}
    exit={{ opacity: 0, y: 10, height: 0 }}
    transition={{ duration: 0.2 }}
  >
    <div className="p-3 border-b border-gray-700 flex justify-between items-center">
      <h3 className="font-medium text-white">保存历史</h3>
      <button 
        onClick={toggleExpand}
        className="text-gray-400 hover:text-white"
        aria-label="关闭历史记录"
      >
        <RiCloseLine />
      </button>
    </div>
    
    <div className="max-h-64 overflow-y-auto">
      {saveHistory.length > 0 ? (
        saveHistory.map(item => (
          <div 
            key={item.id}
            className="p-3 border-b border-gray-700 hover:bg-gray-700/50 transition-colors cursor-pointer"
          >
            <div className="flex justify-between items-start">
              <div className="flex flex-col">
                <span className="text-xs text-gray-400">{item.timestamp}</span>
                <span className="text-xs text-blue-400">{item.platform}</span>
              </div>
              <button 
                className="text-xs text-purple-400 hover:text-purple-300"
                onClick={() => handleRestore(item)}
              >
                恢复
              </button>
            </div>
            <p className="text-sm text-gray-300 mt-1 line-clamp-2">{item.content}</p>
          </div>
        ))
      ) : (
        <div className="p-3 text-center text-gray-400 text-sm">
          暂无保存历史
        </div>
      )}
    </div>
  </motion.div>
)}
```

## 4. 开源项目参考

### 4.1 ChatALL

ChatALL是一个支持多种AI平台的聊天客户端，它通过在Electron应用中嵌入各种AI平台的网页，并使用特定的脚本来与这些网页交互，实现对多个AI平台的统一访问。

**关键点**：
- 使用Electron的webview来加载各AI平台的网页
- 为每个平台编写特定的交互脚本
- 使用消息传递机制在主进程和渲染进程之间通信

### 4.2 ChatGPT-Exporter

ChatGPT-Exporter是一个用于导出ChatGPT对话的浏览器扩展，它能够将对话内容导出为多种格式，包括Markdown、HTML、JSON等。

**关键点**：
- 使用DOM选择器定位对话内容
- 支持多种导出格式
- 使用MutationObserver监听页面变化

### 4.3 Microsoft Teams Chat Extractor

这是一个用于从Microsoft Teams网页版提取聊天记录的Chrome扩展，它能够将聊天内容复制到剪贴板。

**关键点**：
- 详细分析了Teams聊天的DOM结构
- 使用简单的按钮触发提取操作
- 提供了清晰的用户界面

### 4.4 Bing Chat Exporter

这是一个用于导出Bing Chat对话的Chrome扩展，它能够将对话内容保存为txt文件。

**关键点**：
- 在Bing Chat界面添加导出按钮
- 使用简单的文件下载机制
- 支持自定义文件名

## 5. 最佳实践

### 5.1 性能优化

1. **使用防抖和节流**：避免频繁触发捕获逻辑，特别是在监听DOM变化时。
2. **懒加载**：只在需要时加载资源和执行逻辑。
3. **批量处理**：将多个操作合并为一个批量操作，减少API调用和存储操作的次数。

### 5.2 错误处理

1. **优雅降级**：当捕获失败时，提供备用方案或友好的错误提示。
2. **重试机制**：对于网络请求等可能失败的操作，实现重试机制。
3. **日志记录**：记录详细的错误信息，便于调试和问题排查。

### 5.3 用户体验

1. **状态反馈**：提供清晰的状态反馈，让用户知道当前的操作状态。
2. **可配置性**：允许用户配置自动保存的行为，如开启/关闭、保存频率等。
3. **隐私控制**：尊重用户隐私，提供明确的隐私政策和控制选项。

### 5.4 适应性设计

1. **平台特定逻辑分离**：将针对不同AI平台的捕获逻辑分离，便于维护和更新。
2. **选择器冗余**：使用多种选择器策略，当一种选择器失效时可以尝试其他选择器。
3. **版本检测**：检测AI平台的版本或特征，适应不同版本的DOM结构。

## 6. 测试策略

### 6.1 单元测试

为核心功能编写单元测试，确保各个组件的正确性：

```javascript
test('应该正确捕获ChatGPT对话', () => {
  // 模拟DOM结构
  document.body.innerHTML = `
    <main>
      <div class="flex flex-col items-center">
        <div class="group">
          <div data-message-author-role="user">用户提问</div>
        </div>
        <div class="group">
          <div data-message-author-role="assistant">AI回答</div>
        </div>
      </div>
    </main>
  `;
  
  // 执行捕获逻辑
  const conversations = captureChatGPTConversation();
  
  // 验证结果
  expect(conversations).toHaveLength(1);
  expect(conversations[0].prompt).toBe('用户提问');
  expect(conversations[0].response).toBe('AI回答');
  expect(conversations[0].platform).toBe('ChatGPT');
});
```

### 6.2 集成测试

测试整个自动保存流程，从捕获到存储再到UI更新：

```javascript
test('应该完成完整的自动保存流程', async () => {
  // 模拟DOM结构
  document.body.innerHTML = `...`;
  
  // 模拟chrome API
  global.chrome = {
    runtime: {
      sendMessage: jest.fn((message, callback) => {
        callback({ success: true });
      })
    },
    storage: {
      local: {
        get: jest.fn((key, callback) => {
          callback({ conversationHistory: [] });
        }),
        set: jest.fn((data, callback) => {
          callback();
        })
      }
    }
  };
  
  // 初始化自动保存
  initAutoSave();
  
  // 模拟DOM变化
  const observer = new MutationObserver(() => {});
  observer.observe(document.body, { childList: true });
  
  // 触发DOM变化
  document.body.appendChild(document.createElement('div'));
  
  // 等待异步操作完成
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  // 验证结果
  expect(chrome.runtime.sendMessage).toHaveBeenCalled();
  expect(chrome.storage.local.set).toHaveBeenCalled();
});
```

### 6.3 端到端测试

使用Puppeteer或Playwright等工具进行端到端测试，模拟真实用户操作：

```javascript
test('应该在真实环境中正确工作', async () => {
  // 启动浏览器
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  
  // 安装扩展
  // ...
  
  // 访问AI平台
  await page.goto('https://chat.openai.com/');
  
  // 登录
  // ...
  
  // 发送消息
  await page.type('textarea', '测试消息');
  await page.keyboard.press('Enter');
  
  // 等待回复
  await page.waitForSelector('[data-message-author-role="assistant"]');
  
  // 验证自动保存状态
  const saveStatus = await page.evaluate(() => {
    return document.querySelector('#aetherflow-save-status').textContent;
  });
  
  expect(saveStatus).toContain('已保存');
  
  // 关闭浏览器
  await browser.close();
});
```

## 7. 维护与更新

### 7.1 监控AI平台变化

定期检查AI平台的DOM结构变化，及时更新捕获逻辑：

1. 设置自动化测试，定期运行端到端测试，检测捕获功能是否正常工作。
2. 收集用户反馈，及时发现和解决问题。
3. 关注AI平台的官方更新和公告，预先了解可能的变化。

### 7.2 版本控制

使用语义化版本控制，明确标记不兼容的变更：

1. 主版本号：不兼容的API变更
2. 次版本号：向后兼容的功能性新增
3. 修订号：向后兼容的问题修正

### 7.3 文档更新

保持文档的及时更新，包括：

1. 代码注释
2. API文档
3. 用户指南
4. 开发者指南

## 8. 结论

自动存储功能是AetherFlow的核心功能之一，它能够帮助用户高效管理和复用提示词。通过合理的架构设计和实现，可以克服不同AI平台的DOM结构差异等技术挑战，提供稳定可靠的自动存储功能。

参考开源项目的实现方式，结合最佳实践，可以构建出高质量的自动存储功能，为用户提供良好的体验。

## 9. 参考资源

1. [ChatALL](https://github.com/ai-shifu/ChatALL)
2. [ChatGPT-Exporter](https://github.com/pionxzh/chatgpt-exporter)
3. [Microsoft Teams Chat Extractor](https://github.com/ingo/microsoft-teams-chat-extractor)
4. [Bing Chat Exporter](https://github.com/defineprogramming/bing-chat-exporter)
5. [ChatHub](https://github.com/chathub-dev/chathub)
6. [Chrome Extension Documentation](https://developer.chrome.com/docs/extensions/)
7. [MutationObserver API](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) 