# AetherFlow 后端架构设计

## 目录
1. [概述](#概述)
2. [技术栈选择](#技术栈选择)
3. [系统架构](#系统架构)
4. [数据库设计](#数据库设计)
5. [API设计](#api设计)
6. [缓存策略](#缓存策略)
7. [异步任务处理](#异步任务处理)
8. [日志和监控](#日志和监控)
9. [部署架构](#部署架构)
10. [扩展性考虑](#扩展性考虑)
11. [安全性考虑](#安全性考虑)
12. [性能优化](#性能优化)
13. [错误处理](#错误处理)
14. [架构演进](#架构演进)
15. [经验教训](#经验教训)
16. [未来规划](#未来规划)

## 概述
本文档定义了AetherFlow项目的后端架构设计，包括技术选型、系统架构、数据库设计和API设计，为后端开发提供指导。本文档反映了当前的实际实现情况，并记录了从初始设计到当前实现的演进过程。

## 技术栈选择

### 主要技术栈
- **编程语言**：Node.js
- **Web框架**：Express.js
- **数据库**：MongoDB
- **认证**：JWT (JSON Web Token)
- **API文档**：Swagger/OpenAPI
- **测试框架**：Jest
- **ORM/ODM**：Mongoose
- **日志**：Winston
- **部署**：Docker + Docker Compose

### 技术选择理由
1. **Node.js + Express.js**：
   - 适合构建轻量级、高性能的API服务
   - 丰富的中间件生态系统
   - 与前端JavaScript技术栈一致，降低开发复杂性
   - 异步非阻塞I/O模型适合处理高并发请求

2. **MongoDB**：
   - 文档型数据库适合存储结构灵活的Prompt数据
   - 良好的水平扩展能力
   - 原生支持JSON格式，与JavaScript无缝集成
   - 强大的查询功能支持复杂的数据筛选和聚合

3. **JWT认证**：
   - 无状态认证机制，适合分布式系统
   - 减少数据库查询，提高性能
   - 支持跨域认证

## 系统架构

### 当前实现架构
当前实现采用了简化的架构，主要包括：

```
                 ┌───────────────────┐
                 │                   │
                 │   Express API     │
                 │     服务器        │
                 │                   │
                 └─────────┬─────────┘
                           │
                           │
                 ┌─────────▼─────────┐
                 │                   │
                 │     MongoDB       │
                 │                   │
                 └───────────────────┘
```

### 服务层次结构
1. **路由层**：定义API端点和路由处理
2. **控制器层**：处理HTTP请求和响应
3. **服务层**：实现业务逻辑
4. **数据访问层**：通过Mongoose与MongoDB交互
5. **外部服务集成层**：与大模型API等外部服务交互

### 模块划分
1. **认证模块**：用户注册、登录、权限控制
2. **提示词管理模块**：提示词的CRUD操作
3. **标签管理模块**：标签的CRUD操作
4. **会话管理模块**：会话的CRUD操作和消息管理
5. **活动日志模块**：用户活动记录和查询
6. **提示词优化模块**：调用大模型API优化提示词
7. **API密钥管理模块**：管理外部API服务的密钥

## 数据库设计

### 数据模型

#### 用户模型 (User)
```javascript
{
  _id: ObjectId,
  username: String,
  email: String,
  password: String (hashed),
  role: String (enum: ['user', 'admin']),
  settings: {
    theme: String,
    language: String,
    notifications: Boolean
  },
  lastLogin: Date,
  passwordChangedAt: Date,
  createdAt: Date,
  updatedAt: Date
}
```

#### 提示词模型 (Prompt)
```javascript
{
  _id: ObjectId,
  user: ObjectId (ref: 'User'),
  content: String,
  response: String,
  platform: String,
  url: String,
  tags: [ObjectId] (ref: 'Tag'),
  favorite: Boolean,
  usageCount: Number,
  metrics: {
    clarity: Number,
    specificity: Number,
    creativity: Number,
    relevance: Number,
    effectiveness: Number
  },
  createdAt: Date,
  updatedAt: Date
}
```

#### 标签模型 (Tag)
```javascript
{
  _id: ObjectId,
  user: ObjectId (ref: 'User'),
  name: String,
  color: String,
  createdAt: Date,
  updatedAt: Date
}
```

#### 会话模型 (Conversation)
```javascript
{
  _id: ObjectId,
  user: ObjectId (ref: 'User'),
  model: String,
  title: String,
  messages: [
    {
      role: String (enum: ['user', 'assistant']),
      content: String,
      timestamp: Date
    }
  ],
  tags: [ObjectId] (ref: 'Tag'),
  createdAt: Date,
  updatedAt: Date
}
```

#### 活动日志模型 (ActivityLog)
```javascript
{
  _id: ObjectId,
  user: ObjectId (ref: 'User'),
  action: String (enum: [
    'login', 'logout', 'register', 
    'create_prompt', 'update_prompt', 'delete_prompt', 
    'favorite_prompt', 'use_prompt', 'auto_save_prompt',
    'create_tag', 'update_tag', 'delete_tag',
    'create_conversation', 'update_conversation', 'delete_conversation',
    'add_message', 'clear_messages',
    'enhance_prompt', 'optimize', 'rate_optimization',
    'create_api_key', 'update_api_key', 'delete_api_key',
    'clear_activities'
  ]),
  entityType: String (enum: ['User', 'Prompt', 'Tag', 'Conversation', 'OptimizationHistory', 'ApiKey', 'prompt', 'tag', 'conversation', 'api_key', 'activity_log', null]),
  entityId: ObjectId,
  details: Object,
  ipAddress: String,
  userAgent: String,
  createdAt: Date,
  updatedAt: Date
}
```

#### 优化历史模型 (OptimizationHistory)
```javascript
{
  _id: ObjectId,
  user: ObjectId (ref: 'User'),
  originalPrompt: String,
  optimizedPrompt: String,
  improvements: String,
  expectedBenefits: String,
  category: String,
  provider: String,
  model: String,
  rating: Number,
  iterations: [
    {
      optimizedPrompt: String,
      improvements: String,
      expectedBenefits: String,
      timestamp: Date
    }
  ],
  createdAt: Date,
  updatedAt: Date
}
```

#### API密钥模型 (ApiKey)
```javascript
{
  _id: ObjectId,
  user: ObjectId (ref: 'User'),
  provider: String (enum: ['openai', 'deepseek', 'moonshot', 'custom']),
  encryptedKey: String,
  iv: String,
  baseUrl: String,
  modelName: String,
  isActive: Boolean,
  createdAt: Date,
  updatedAt: Date
}
```

### 索引设计
1. **用户集合索引**：
   - `username`: 唯一索引
   - `email`: 唯一索引

2. **提示词集合索引**：
   - `user`: 索引
   - `createdAt`: 索引
   - `tags`: 索引
   - `favorite`: 索引
   - `content`: 文本索引

3. **标签集合索引**：
   - `user, name`: 复合唯一索引

4. **会话集合索引**：
   - `user, createdAt`: 复合索引

5. **活动日志集合索引**：
   - `user, createdAt`: 复合索引

6. **优化历史集合索引**：
   - `user, createdAt`: 复合索引
   - `user, category`: 复合索引

7. **API密钥集合索引**：
   - `user, provider`: 复合唯一索引

### 数据关系
1. **用户与提示词**：一对多关系
2. **用户与标签**：一对多关系
3. **提示词与标签**：多对多关系
4. **用户与会话**：一对多关系
5. **用户与活动日志**：一对多关系
6. **用户与优化历史**：一对多关系
7. **用户与API密钥**：一对多关系

## API设计

### RESTful API端点

#### 认证API
- `POST /auth/register` - 用户注册
- `POST /auth/login` - 用户登录
- `GET /auth/me` - 获取当前用户信息
- `PATCH /auth/updateMe` - 更新用户信息
- `POST /auth/logout` - 用户登出

#### 提示词管理API
- `GET /prompts` - 获取提示词列表
- `GET /prompts/:id` - 获取单个提示词
- `POST /prompts` - 创建提示词
- `PATCH /prompts/:id` - 更新提示词
- `DELETE /prompts/:id` - 删除提示词
- `POST /prompts/:id/favorite` - 收藏/取消收藏提示词
- `POST /prompts/:id/usage` - 增加提示词使用次数
- `POST /prompts/auto-save` - 自动保存提示词
- `POST /prompts/batch` - 批量操作提示词

#### 标签管理API
- `GET /tags` - 获取标签列表
- `GET /tags/:id` - 获取单个标签
- `POST /tags` - 创建标签
- `PATCH /tags/:id` - 更新标签
- `DELETE /tags/:id` - 删除标签
- `GET /tags/:id/prompts` - 获取标签关联的提示词

#### 会话管理API
- `GET /conversations` - 获取会话列表
- `GET /conversations/:id` - 获取单个会话
- `POST /conversations` - 创建会话
- `PATCH /conversations/:id` - 更新会话
- `DELETE /conversations/:id` - 删除会话
- `POST /conversations/:id/messages` - 添加会话消息

#### 活动日志API
- `GET /activities` - 获取活动日志列表
- `DELETE /activities` - 清除活动日志
- `GET /activities/stats` - 获取活动统计数据

#### 提示词优化API
- `POST /optimize` - 优化提示词
- `GET /optimize/history` - 获取优化历史
- `GET /optimize/history/:id` - 获取单个优化历史
- `POST /optimize/history/:id/rate` - 评价优化结果
- `GET /optimize/config` - 获取优化配置

#### API密钥管理API
- `GET /api-keys` - 获取API密钥列表
- `POST /api-keys` - 创建API密钥
- `PATCH /api-keys/:id` - 更新API密钥
- `DELETE /api-keys/:id` - 删除API密钥
- `POST /api-keys/:id/verify` - 验证API密钥

### API安全性
1. **认证中间件**：验证JWT token
2. **授权中间件**：检查用户权限
3. **输入验证**：使用Joi验证请求数据
4. **速率限制**：使用express-rate-limit防止滥用
5. **CORS配置**：限制跨域请求
6. **Helmet**：设置安全相关的HTTP头

## 缓存策略

### 当前实现
当前实现中，缓存策略主要通过应用层实现，包括：

1. **内存缓存**：对频繁访问的数据进行内存缓存
2. **查询结果缓存**：缓存常用查询结果，减少数据库访问
3. **响应缓存**：对不经常变化的API响应进行缓存

### 未来计划
计划引入Redis作为分布式缓存解决方案，实现：

1. **用户会话缓存**：存储用户会话信息
2. **热门提示词缓存**：缓存频繁访问的提示词
3. **仪表盘数据缓存**：缓存计算密集型的仪表盘数据
4. **API响应缓存**：缓存不经常变化的API响应

## 异步任务处理

### 当前实现
当前实现中，异步任务主要通过Promise和async/await处理，包括：

1. **提示词优化**：异步调用大模型API
2. **数据导出**：异步处理数据导出请求
3. **批量操作**：异步处理批量数据操作

### 未来计划
计划引入Bull队列作为任务队列解决方案，处理：

1. **提示词优化**：调用大模型API优化提示词
2. **数据分析**：生成仪表盘数据
3. **邮件发送**：发送通知邮件
4. **数据导出**：导出用户数据

## 日志和监控

### 日志策略
1. **应用日志**：使用Winston记录应用日志
2. **请求日志**：使用Morgan记录HTTP请求日志
3. **错误日志**：详细记录错误信息和堆栈跟踪
4. **活动日志**：记录用户活动到数据库

### 监控系统
1. **健康检查端点**：`GET /health`
2. **基本性能监控**：记录API响应时间和错误率

### 未来计划
计划引入更完善的监控系统：

1. **性能指标**：使用Prometheus收集性能指标
2. **告警系统**：配置关键指标的告警阈值
3. **分布式追踪**：使用Jaeger或Zipkin进行分布式追踪

## 部署架构

### 当前实现
当前实现采用简化的部署架构：

1. **开发环境**：本地运行Node.js服务和MongoDB
2. **测试环境**：简单的服务器部署

### 未来计划
计划引入更完善的部署架构：

1. **容器化**：使用Docker容器化应用
2. **编排**：使用Docker Compose或Kubernetes进行服务编排
3. **CI/CD**：实现持续集成和持续部署
4. **多环境**：开发、测试、预发布、生产环境分离

## 扩展性考虑

### 当前实现
当前实现主要考虑了以下扩展性因素：

1. **模块化设计**：功能按模块划分，便于扩展
2. **中间件架构**：使用Express中间件架构，便于添加新功能
3. **配置驱动**：关键参数通过配置文件或环境变量控制

### 未来计划
计划引入更多扩展性措施：

1. **微服务拆分**：将大型服务拆分为小型专用服务
2. **API网关**：引入API网关统一管理服务
3. **服务发现**：实现服务自动发现和注册
4. **消息队列**：使用消息队列实现服务间通信

## 安全性考虑

### 数据安全
1. **密码加密**：使用bcrypt加密存储用户密码
2. **API密钥加密**：使用对称加密存储API密钥
3. **数据隔离**：不同用户的数据严格隔离

### 应用安全
1. **输入验证**：所有用户输入经过验证
2. **CSRF防护**：实现CSRF令牌验证
3. **XSS防护**：使用Helmet设置安全相关HTTP头
4. **权限控制**：实现基于角色的访问控制

### 未来计划
计划引入更多安全措施：

1. **依赖扫描**：定期扫描和更新依赖
2. **渗透测试**：定期进行渗透测试
3. **安全审计**：实现安全日志审计
4. **数据加密**：实现更多敏感数据的加密存储

## 性能优化

### 数据库优化
1. **索引优化**：根据查询模式优化索引
2. **查询优化**：优化复杂查询，避免N+1问题
3. **批量操作**：使用批量操作减少数据库交互

### API性能
1. **响应压缩**：启用gzip压缩
2. **分页**：大数据集实现分页
3. **字段筛选**：支持只返回请求的字段

### 未来计划
计划引入更多性能优化措施：

1. **缓存优化**：实现多级缓存
2. **数据库分片**：实现数据库水平分片
3. **CDN加速**：使用CDN加速静态资源
4. **负载均衡**：实现负载均衡

## 错误处理

### 错误分类
1. **客户端错误**：400系列状态码
2. **服务器错误**：500系列状态码
3. **业务逻辑错误**：自定义错误码

### 错误响应格式
```json
{
  "success": false,
  "status": "error",
  "message": "用户友好的错误消息",
  "error": {
    "statusCode": 400,
    "status": "error",
    "isOperational": true
  }
}
```

### 未来计划
计划引入更完善的错误处理机制：

1. **错误聚合**：使用Sentry等工具聚合错误
2. **错误分析**：定期分析常见错误，优化系统
3. **告警机制**：关键错误触发告警

## 架构演进

### 初始设计到当前实现
从初始设计到当前实现，架构经历了以下演进：

1. **简化部署架构**：从多实例部署简化为单实例部署
2. **调整数据模型**：根据实际需求调整了数据模型字段和关系
3. **扩展API端点**：增加了更多API端点，如自动保存、批量操作等
4. **添加新模块**：增加了API密钥管理、优化历史等新模块
5. **调整API路径**：从`/api/v1`前缀简化为直接使用功能模块名称

### 演进原因
架构演进的主要原因包括：

1. **实际需求变化**：根据实际业务需求调整架构
2. **开发资源限制**：根据可用开发资源调整实现复杂度
3. **技术选型调整**：根据团队技术栈和经验调整技术选型
4. **性能考虑**：根据性能测试结果调整架构

## 经验教训

### 技术选型
1. **选择成熟技术**：选择成熟稳定的技术栈，减少技术风险
2. **考虑团队经验**：技术选型应考虑团队已有经验和技能
3. **避免过度设计**：初期避免过度设计，随着项目发展逐步完善

### 开发流程
1. **迭代开发**：采用迭代开发方式，逐步完善功能
2. **测试驱动**：尽早引入测试，确保代码质量
3. **文档同步**：及时更新文档，确保文档与代码一致

### 架构设计
1. **模块化设计**：采用模块化设计，便于扩展和维护
2. **关注点分离**：明确分离不同层次的职责
3. **统一规范**：制定并遵循统一的编码和API设计规范

## 未来规划

### 短期计划
1. **提高测试覆盖率**：增加单元测试和集成测试
2. **完善文档**：更新API文档，确保与实际实现一致
3. **优化性能**：优化数据库查询和API响应性能

### 中期计划
1. **引入缓存**：实现Redis缓存，提高性能
2. **引入任务队列**：实现Bull任务队列，处理异步任务
3. **完善监控**：实现更完善的监控和告警系统

### 长期计划
1. **微服务拆分**：将系统拆分为微服务架构
2. **容器化部署**：实现Docker容器化部署
3. **自动扩展**：实现系统自动扩展能力 