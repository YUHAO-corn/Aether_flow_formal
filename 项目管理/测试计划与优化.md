# AetherFlow 测试计划与优化

## 目录
1. [测试计划](#测试计划)
   - [单元测试](#1-单元测试)
   - [集成测试](#2-集成测试)
   - [端到端测试](#3-端到端测试)
   - [性能测试](#4-性能测试)
   - [安全测试](#5-安全测试)
   - [网页测试](#6-网页测试)
2. [集成测试结果总结](#集成测试结果总结)
   - [测试环境](#测试环境)
   - [测试结果摘要](#测试结果摘要)
   - [详细测试结果](#详细测试结果)
   - [总体评估](#总体评估)
   - [后续工作](#后续工作)
3. [API 测试详细计划](#api-测试详细计划)
   - [测试环境](#测试环境-1)
   - [API测试类型](#api测试类型)
   - [API测试执行计划](#api测试执行计划)
   - [API测试用例示例](#api测试用例示例)
   - [API测试数据管理](#api测试数据管理)
   - [API测试自动化](#api测试自动化)
   - [测试执行计划](#测试执行计划)
   - [测试工具和资源](#测试工具和资源)
   - [测试报告](#测试报告)
4. [测试优化记录](#测试优化记录)
   - [测试效率问题分析](#测试效率问题分析)
   - [优化措施](#优化措施)
   - [优化效果](#优化效果)
   - [后续优化计划](#后续优化计划)
5. [前后端数据格式不匹配问题](#前后端数据格式不匹配问题)
   - [问题描述](#问题描述)
   - [问题详情](#问题详情)
   - [解决方案](#解决方案)
   - [相关文档](#相关文档)
   - [后续行动](#后续行动)

## 测试计划

### 1. 单元测试

#### 后端单元测试
- 使用 Jest 进行单元测试
- 测试覆盖所有控制器、服务和模型
- 使用 MongoDB Memory Server 进行数据库测试

#### 前端单元测试
- 使用 Vitest 进行单元测试
- 测试覆盖所有组件和服务
- 使用 React Testing Library 进行组件测试

### 2. 集成测试

#### API 集成测试
- 测试所有 API 端点
- 验证请求和响应格式
- 测试错误处理和边界情况

#### 数据库集成测试
- 测试数据库连接和操作
- 验证数据模型和关系
- 测试数据迁移和种子数据

### 3. 端到端测试

#### 后端端到端测试
- 使用 Supertest 进行 API 测试
- 测试完整的请求-响应流程
- 验证数据持久化和业务逻辑

#### 前端端到端测试
- 使用 Cypress 进行 UI 测试
- 测试用户交互和页面导航
- 验证表单提交和数据显示

### 4. 性能测试

#### API 性能测试
- 使用 Apache JMeter 进行负载测试
- 测试 API 响应时间和吞吐量
- 验证系统在高负载下的稳定性

#### 前端性能测试
- 使用 Lighthouse 进行性能评估
- 测试页面加载时间和交互响应
- 验证资源优化和缓存策略

### 5. 安全测试

#### API 安全测试
- 测试身份验证和授权
- 验证输入验证和 XSS 防护
- 测试 CSRF 防护和安全头部

#### 数据安全测试
- 测试数据加密和脱敏
- 验证敏感信息处理
- 测试数据备份和恢复

### 6. 网页测试

#### 环境准备
- 使用 `scripts/check-web-test-env.sh` 检查测试环境
- 确保 MongoDB 和后端服务正常运行
- 准备测试用户和测试数据

#### 手动测试
- 使用 `scripts/start-web-test.sh` 启动前端服务
- 在浏览器中执行控制台命令修复数据格式
- 测试登录、提示词列表、搜索、标签筛选和登出功能

#### 自动化测试
- 使用 Puppeteer 进行自动化测试
- 执行 `npm run test:web` 运行测试脚本
- 验证所有主要功能的正常运行

#### 测试注意事项
- 前后端数据格式不匹配问题的临时解决方案
- ID 字段映射（_id 到 id）
- 测试用户凭据和测试数据管理

## 集成测试结果总结

### 测试环境

- 后端服务器: Node.js + Express + MongoDB
- 前端: React + Vite
- 测试工具: 自定义测试脚本 + Axios

### 测试结果摘要

| 模块 | 测试状态 | 问题数量 | 备注 |
|------|----------|----------|------|
| 用户认证 | ✅ 通过 | 0 | 注册、登录功能正常 |
| 会话管理 | ✅ 通过 | 0 | 创建、获取、更新、删除会话功能正常 |
| 提示词优化 | ⚠️ 部分通过 | 1 | API密钥配置问题 |
| API密钥管理 | ✅ 通过 | 0 | 添加、获取、更新、删除API密钥功能正常 |
| 活动日志管理 | ⚠️ 部分通过 | 2 | 统计和清除功能存在问题 |
| 提示词自动捕获 | ✅ 通过 | 0 | 已修复entityType验证错误 |

### 详细测试结果

#### 1. 用户认证模块

**测试脚本**: `test-auth.js`

**测试结果**: ✅ 通过

**测试内容**:
- 用户注册
- 用户登录
- 获取用户信息

**备注**: 用户认证模块工作正常，能够成功注册新用户并登录。

#### 2. 会话管理模块

**测试脚本**: `test-conversation-management.js`

**测试结果**: ✅ 通过

**测试内容**:
- 创建会话
- 获取会话列表
- 获取单个会话
- 添加消息到会话
- 获取会话消息
- 更新会话
- 清空会话消息
- 删除会话

**备注**: 会话管理模块工作正常，所有API接口均能正确响应。

#### 3. 提示词优化模块

**测试脚本**: `test-prompt-optimization.js`

**测试结果**: ⚠️ 部分通过

**测试内容**:
- 获取客户端配置
- 优化提示词
- 多轮优化

**发现的问题**:
1. 优化提示词接口返回500错误，提示"未配置openai的API密钥"

**解决方案**:
- 需要在系统中配置默认的API密钥，或者在测试前添加用户API密钥
- 可以修改优化服务，在没有API密钥时使用模拟数据进行测试

#### 4. API密钥管理模块

**测试脚本**: `test-api-key-management.js`

**测试结果**: ✅ 通过

**测试内容**:
- 获取API密钥列表
- 添加API密钥
- 更新API密钥
- 验证API密钥
- 删除API密钥

**备注**: API密钥管理模块工作正常，能够成功添加、更新和删除API密钥。

#### 5. 活动日志管理模块

**测试脚本**: `test-activity-log.js`

**测试结果**: ⚠️ 部分通过

**测试内容**:
- 获取活动日志列表
- 获取活动统计信息
- 获取单个活动日志
- 清除活动日志

**发现的问题**:
1. 获取活动统计信息接口返回500错误
2. 清除活动日志接口返回500错误

**解决方案**:
- 检查活动统计信息接口的实现，特别是MongoDB聚合查询部分
- 检查清除活动日志接口的实现，确保日期处理正确

#### 6. 提示词自动捕获模块

**测试脚本**: `test-prompt-auto-save.js`

**测试结果**: ✅ 通过

**测试内容**:
- 自动保存提示词
- 获取提示词列表
- 获取单个提示词
- 更新提示词（收藏）
- 删除提示词

**已修复的问题**:
1. ActivityLog模型中的entityType枚举值问题已修复，添加了小写的"prompt"、"tag"、"conversation"和"api_key"

**备注**: 提示词自动捕获功能现在工作正常，能够成功保存、获取、更新和删除提示词。

### 总体评估

系统大部分功能正常工作，仍有少数问题需要解决：

1. 提示词优化模块的API密钥配置问题
2. 活动日志管理模块的统计和清除功能问题

这些问题都是可修复的，不影响系统的核心功能。建议按照上述解决方案进行修复，然后重新运行测试脚本验证。

### 后续工作

1. 修复剩余的问题
   - 配置默认API密钥或修改提示词优化服务
   - 修复活动日志统计和清除功能
2. 增加更多的边界条件测试
3. 添加前端集成测试
4. 实现端到端测试
5. 设置持续集成流程，自动运行测试

## API 测试详细计划

### 测试环境

#### 开发环境
- 基础URL: `http://localhost:3000/api/v1`
- 数据库: 开发用MongoDB实例
- 用途: 开发过程中的单元测试和集成测试

#### 测试环境
- 基础URL: `https://test-api.aetherflow.com/api/v1`
- 数据库: 测试用MongoDB实例（与开发环境隔离）
- 用途: QA团队测试、自动化测试、性能测试

#### 生产环境
- 基础URL: `https://api.aetherflow.com/api/v1`
- 数据库: 生产MongoDB集群
- 用途: 最终用户使用

### API测试类型

#### 单元测试
- **目标**: 测试各个API端点的基本功能
- **工具**: Jest, Supertest
- **覆盖范围**: 所有API端点的基本功能
- **预期覆盖率**: 代码覆盖率>85%

#### 集成测试
- **目标**: 测试API端点之间的交互和数据流
- **工具**: Jest, Supertest
- **覆盖范围**: 关键业务流程和多接口交互场景
- **预期覆盖率**: 关键业务流程100%覆盖

#### 端到端测试
- **目标**: 模拟真实用户场景，测试完整功能流程
- **工具**: Cypress
- **覆盖范围**: 用户关键路径和主要功能流程
- **预期覆盖率**: 关键用户路径100%覆盖

#### 性能测试
- **目标**: 评估API在高负载下的性能表现
- **工具**: k6, Artillery
- **测试指标**: 
  - 响应时间: P95 < 500ms
  - 吞吐量: 每秒请求数 > 100
  - 错误率: < 0.1%
- **测试场景**: 
  - 正常负载: 模拟平均用户量
  - 峰值负载: 模拟最高预期用户量
  - 压力测试: 模拟超出预期的极限负载

#### 安全测试
- **目标**: 识别API的安全漏洞
- **工具**: OWASP ZAP, SonarQube
- **测试范围**: 
  - 认证和授权
  - 输入验证
  - 敏感数据处理
  - API限流和防护

### API测试执行计划

#### 第一阶段: 单元测试（1-2天）
1. 为每个API端点编写基本的单元测试
2. 测试正常流程和异常流程
3. 验证响应格式和状态码
4. 确保代码覆盖率达到预期目标

#### 第二阶段: 集成测试（2-3天）
1. 编写测试用例覆盖关键业务流程
2. 测试API端点之间的数据流和状态变化
3. 验证数据一致性和完整性
4. 测试事务处理和回滚机制

#### 第三阶段: 端到端测试（2-3天）
1. 编写模拟用户行为的测试脚本
2. 测试完整的用户流程
3. 验证前后端交互的正确性
4. 测试UI和API的协同工作

#### 第四阶段: 性能测试（1-2天）
1. 设置性能测试环境
2. 编写性能测试脚本
3. 执行不同负载下的性能测试
4. 分析性能瓶颈并优化

#### 第五阶段: 安全测试（1-2天）
1. 执行自动化安全扫描
2. 进行渗透测试
3. 代码安全审查
4. 修复发现的安全问题

### API测试用例示例

#### 认证API测试用例

##### 用户注册测试
1. **正常注册**: 使用有效的用户名、邮箱和密码注册
2. **邮箱已存在**: 使用已存在的邮箱注册
3. **无效邮箱格式**: 使用格式错误的邮箱注册
4. **密码强度不足**: 使用简单密码注册
5. **密码不匹配**: 密码和确认密码不一致

##### 用户登录测试
1. **正常登录**: 使用正确的邮箱和密码登录
2. **邮箱不存在**: 使用不存在的邮箱登录
3. **密码错误**: 使用错误的密码登录
4. **账户锁定**: 多次密码错误后尝试登录

#### 提示词API测试用例

##### 获取提示词列表测试
1. **无筛选获取**: 获取默认提示词列表
2. **分页测试**: 测试不同页码和每页数量
3. **搜索测试**: 使用关键词搜索提示词
4. **标签筛选**: 按标签筛选提示词
5. **多条件组合**: 组合多个筛选条件

##### 创建提示词测试
1. **基本创建**: 创建包含基本信息的提示词
2. **带标签创建**: 创建包含标签的提示词
3. **无内容创建**: 尝试创建没有内容的提示词
4. **超长内容**: 尝试创建内容超长的提示词

#### 标签API测试用例

##### 获取标签列表测试
1. **获取所有标签**: 获取用户的所有标签
2. **搜索标签**: 按名称搜索标签
3. **排序测试**: 测试不同排序方式

##### 创建标签测试
1. **基本创建**: 创建基本标签
2. **重复名称**: 创建名称重复的标签
3. **无名称创建**: 尝试创建没有名称的标签

### API测试数据管理

1. **测试数据准备**: 
   - 使用工厂模式生成测试数据
   - 准备各种测试场景的数据集

2. **测试数据隔离**:
   - 每个测试用例使用独立的数据集
   - 测试完成后清理测试数据

3. **数据库重置**:
   - 每次测试运行前重置测试数据库
   - 使用种子数据初始化测试环境

4. **测试用户管理**:
   - 创建不同角色的测试用户
   - 管理测试用户的认证令牌

### API测试自动化

1. **CI/CD集成**:
   - 在每次代码提交时运行单元测试
   - 在每次合并请求时运行集成测试
   - 在每次发布前运行完整测试套件

2. **测试报告**:
   - 生成详细的测试报告
   - 跟踪测试覆盖率变化
   - 可视化测试结果

3. **测试监控**:
   - 监控测试执行时间
   - 跟踪测试失败率
   - 分析测试稳定性

### 测试执行计划

1. 开发阶段：
   - 单元测试和集成测试随开发进行
   - 每次提交代码前运行相关测试

2. 集成阶段：
   - 端到端测试和网页测试在功能完成后进行
   - 每周进行一次完整的测试套件运行

3. 发布前：
   - 性能测试和安全测试在发布前进行
   - 进行全面的回归测试

4. 发布后：
   - 定期进行监控和性能测试
   - 根据用户反馈进行针对性测试

### 测试工具和资源

- Jest 和 Vitest：单元测试框架
- Supertest：API 测试工具
- Puppeteer：浏览器自动化测试工具
- MongoDB Memory Server：数据库测试工具
- Apache JMeter：性能测试工具
- Lighthouse：前端性能测试工具

### 测试报告

测试报告将包含以下内容：
- 测试覆盖率统计
- 测试通过率
- 发现的问题和严重程度
- 性能指标和基准
- 安全评估结果

测试报告将在每次测试执行后生成，并提交给项目管理团队进行审核。

## 测试优化记录

### 测试效率问题分析

在项目开发过程中，我们发现集成测试执行时间过长，主要存在以下问题：

1. **数据库连接问题**：每个测试文件都独立创建MongoDB连接，导致连接资源浪费
2. **测试超时问题**：部分测试用例执行时间超过默认超时时间，导致测试失败
3. **测试进程未正常退出**：测试完成后进程仍在运行，需要手动终止
4. **重复的数据库操作**：测试中存在大量重复的数据库操作，降低测试效率
5. **加密密钥问题**：API密钥测试中使用实际加密函数导致错误

### 优化措施

#### 1. 测试配置优化

- 优化Jest配置文件 `jest.config.js`：
  ```javascript
  module.exports = {
    testEnvironment: 'node',
    testMatch: ['**/tests/**/*.test.js'],
    collectCoverage: false,
    maxWorkers: '50%',
    testTimeout: 10000, // 减少超时时间
    setupFilesAfterEnv: ['./src/tests/setup.js'],
    forceExit: true, // 强制退出测试进程
    detectOpenHandles: true, // 检测打开的句柄
  };
  ```

- 添加多种测试命令到 `package.json`：
  ```json
  "scripts": {
    "test:parallel": "jest --maxWorkers=50%",
    "test:fast": "jest --bail --forceExit",
    "test:ci": "jest --ci --bail --forceExit --detectOpenHandles",
    "test:mock": "MOCK_DB=true jest --bail --forceExit",
    "test:quick": "jest --bail --forceExit --silent",
    "test:single": "jest --testNamePattern"
  }
  ```

#### 2. 数据库连接优化

- 实现全局数据库连接，避免每个测试文件创建独立连接：
  ```javascript
  // 全局连接实例
  let mongoConnection;

  // 连接到MongoDB
  const connectToMongoDB = async () => {
    try {
      mongoConnection = await mongoose.connect(process.env.MONGODB_URI, mongooseOptions);
      console.log('已连接到MongoDB服务器');
      return true;
    } catch (error) {
      console.error('连接MongoDB失败:', error);
      return false;
    }
  };
  ```

- 添加连接重试机制，提高测试稳定性：
  ```javascript
  // 尝试连接到MongoDB，最多重试3次
  let connected = false;
  let retries = 0;
  
  while (!connected && retries < 3) {
    connected = await connectToMongoDB();
    if (!connected) {
      retries++;
      console.log(`连接MongoDB失败，重试 ${retries}/3...`);
      // 等待2秒后重试
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  ```

#### 3. 测试结构优化

- 优化API密钥集成测试，使用独立测试用例替代连续测试：
  ```javascript
  // 使用单个测试用例测试API密钥的添加功能
  test('应成功添加API密钥', async () => {
    // 测试代码
  }, 30000); // 增加测试超时时间
  
  // 使用单个测试用例测试API密钥的获取功能
  test('应成功获取API密钥列表', async () => {
    // 直接创建API密钥，避免通过API请求
    const { encryptedKey, iv } = mockEncryptKey(testApiKey.key);
    await ApiKey.create({
      // 数据
    });
    
    // 测试代码
  });
  ```

- 使用模拟加密函数，避免实际加密过程中的错误：
  ```javascript
  // 模拟加密方法，避免使用真实的加密函数
  const mockEncryptKey = (apiKey) => {
    const iv = crypto.randomBytes(16);
    // 使用固定的测试密钥而不是从环境变量获取
    const testKey = Buffer.from('0123456789abcdef0123456789abcdef');
    const encryptedKey = 'mock-encrypted-key';
    return { encryptedKey, iv: iv.toString('hex') };
  };
  ```

#### 4. 错误处理优化

- 添加数据库操作错误处理：
  ```javascript
  try {
    const collections = mongoose.connection.collections;
    
    for (const key in collections) {
      const collection = collections[key];
      await collection.deleteMany({});
    }
  } catch (error) {
    console.error('清空数据库失败:', error);
  }
  ```

- 添加测试用户创建错误处理：
  ```javascript
  try {
    // 创建用户代码
    return { user, token };
  } catch (error) {
    console.error('创建测试用户失败:', error);
    // 返回模拟用户数据
    const mockUser = {
      _id: new mongoose.Types.ObjectId(),
      username: 'mockuser',
      email: 'mock@example.com'
    };
    
    const token = jwt.sign(
      { id: mockUser._id },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN }
    );
    
    return { user: mockUser, token };
  }
  ```

### 优化效果

1. **测试执行时间**：通过并行执行和优化测试结构，测试执行时间预计减少50%以上
2. **测试稳定性**：通过添加错误处理和连接重试机制，测试稳定性显著提高
3. **开发效率**：通过提供多种测试命令，开发人员可以根据需要选择最适合的测试方式
4. **资源利用**：通过全局数据库连接和优化连接池设置，减少了资源消耗

### 后续优化计划

1. **测试数据缓存**：实现测试数据缓存机制，减少重复的数据库操作
2. **测试快照**：使用Jest快照测试功能，简化响应验证过程
3. **测试分组**：按功能模块分组测试，实现更精细的测试控制
4. **测试报告优化**：生成更详细的测试报告，便于问题定位
5. **CI/CD集成**：将优化后的测试集成到CI/CD流程中，实现自动化测试

## 前后端数据格式不匹配问题

### 问题描述
在测试过程中发现，前端应用仍然显示模拟数据，而不是从后端API获取的真实数据。经过调查，这是由于前后端数据格式不匹配导致的。

### 问题详情

1. **API响应格式不匹配**：
   - 后端API返回的数据格式是：`{ success: true, status: "success", data: [...] }`
   - 而前端代码期望的格式是：`{ data: { prompts: [...] } }`

2. **ID字段不匹配**：
   - 后端返回的提示词ID字段是`_id`
   - 前端代码期望的是`id`

### 解决方案

1. **临时解决方案**：
   - 在浏览器控制台中修改`apiClient.get`方法，转换响应格式
   - 将后端返回的`_id`字段映射为前端期望的`id`字段

2. **长期解决方案**：
   - 修改前端代码中的API响应类型定义
   - 更新提示词类型定义，添加`_id`字段
   - 修改数据获取逻辑，适配后端API的响应格式

### 相关文档
- 详细解决方案已记录在[协作指南.md](./协作指南.md)文档中
- 前端开发人员需要根据该文档进行代码修改

### 后续行动
- [ ] 前端开发人员实施长期解决方案
- [ ] 更新API文档，确保前后端接口规范一致
- [ ] 添加集成测试，验证数据格式兼容性 